global:
  image:
    # -- Overrides the Docker registry globally for all images, excluding enterprise.
    registry: gsoci.azurecr.io
    # -- Optional list of imagePullSecrets for all images, excluding enterprise.
    # Names of existing secrets with private container registry credentials.
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    # Example:
    # pullSecrets: [ my-dockerconfigjson-secret ]
    pullSecrets: []
  # -- Overrides the priorityClassName for all pods
  priorityClassName:
  # -- configures cluster domain ("cluster.local" by default)
  clusterDomain: 'cluster.local'
  # -- configures DNS service name
  dnsService: 'coredns'
  # -- configures DNS service namespace
  dnsNamespace: 'kube-system'

tempo:
  # You can make the whole chart ineffective by setting this one to "false"
  enabled: true

  distributor:
    autoscaling:
      enabled: true
      minReplicas: 2
      targetCPUUtilizationPercentage: 60
    affinity: |
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                {{- include "tempo.selectorLabels" (dict "ctx" . "component" "distributor") | nindent 10 }}
            topologyKey: kubernetes.io/hostname
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  {{- include "tempo.selectorLabels" (dict "ctx" . "component" "distributor") | nindent 12 }}
              topologyKey: topology.kubernetes.io/zone
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: node-role.kubernetes.io/control-plane
              operator: DoesNotExist

  gateway:
    enabled: true
    autoscaling:
      enabled: true
      minReplicas: 2
      targetCPUUtilizationPercentage: 90
    image:
      repository: giantswarm/nginx-unprivileged
    resources:
      limits:
        memory: 500Mi
      requests:
        memory: 50Mi
        cpu: 50m

  ingester:
    affinity: |
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  {{- include "tempo.selectorLabels" (dict "ctx" . "component" "ingester") | nindent 12 }}
              topologyKey: kubernetes.io/hostname
          - weight: 75
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  {{- include "tempo.selectorLabels" (dict "ctx" . "component" "ingester") | nindent 12 }}
              topologyKey: topology.kubernetes.io/zone
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: node-role.kubernetes.io/control-plane
              operator: DoesNotExist
    persistence:
      enabled: true

  memcached:
    enabled: true
    image:
      repository: giantswarm/memcached

  metaMonitoring:
    # ServiceMonitor configuration
    serviceMonitor:
      enabled: true
      # Make this a string type because of an upstream issue https://github.com/grafana/helm-charts/blob/fdb555b8be1131d5ae4f5f8829a2c6508e3df4ca/charts/tempo-distributed/templates/lib/service-monitor.tpl#L53C33-L53C45
      clusterLabel: "tempo"
    grafanaAgent:
      enabled: false
    prometheusRule:
      enabled: false

  metricsGenerator:
    enabled: true
    kind: StatefulSet
    affinity: |
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                {{- include "tempo.selectorLabels" (dict "ctx" . "component" "metrics-generator") | nindent 10 }}
            topologyKey: kubernetes.io/hostname
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  {{- include "tempo.selectorLabels" (dict "ctx" . "component" "metrics-generator") | nindent 12 }}
              topologyKey: topology.kubernetes.io/zone
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: node-role.kubernetes.io/control-plane
              operator: DoesNotExist
    persistence:
      enabled: true

  querier:
    affinity: |
      podAntiAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchLabels:
                {{- include "tempo.selectorLabels" (dict "ctx" . "component" "querier" "memberlist" true) | nindent 10 }}
            topologyKey: kubernetes.io/hostname
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  {{- include "tempo.selectorLabels" (dict "ctx" . "component" "querier" "memberlist" true) | nindent 12 }}
              topologyKey: topology.kubernetes.io/zone
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: node-role.kubernetes.io/control-plane
              operator: DoesNotExist

  queryFrontend:
    affinity: |
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  {{- include "tempo.selectorLabels" (dict "ctx" . "component" "query-frontend") | nindent 12 }}
              topologyKey: kubernetes.io/hostname
          - weight: 75
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  {{- include "tempo.selectorLabels" (dict "ctx" . "component" "query-frontend") | nindent 12 }}
              topologyKey: topology.kubernetes.io/zone
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: node-role.kubernetes.io/control-plane
              operator: DoesNotExist

  rbac:
    pspEnabled: true
    pspAnnotations:
      seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'

  serviceAccount:
    # -- Specifies whether a ServiceAccount should be created
    create: true
    # -- The name of the ServiceAccount to use.
    # If not set and create is true, a name is generated using the fullname template
    name: tempo
    # -- Image pull secrets for the service account
    imagePullSecrets: []
    # -- Annotations for the service account
    annotations: {}
    automountServiceAccountToken: true

  tempo:
    structuredConfig:
      usage_report:
        reporting_enabled: false
      # Support streaming of queries
      stream_over_http_enabled: true
    image:
      # -- Docker image repository
      repository: giantswarm/tempo
    securityContext:
      runAsNonRoot: true
      runAsUser: 1000
      runAsGroup: 1000
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
      capabilities:
        drop:
          - ALL
      seccompProfile:
        type: RuntimeDefault
    # -- podSecurityContext holds pod-level security attributes and common container settings
    podSecurityContext:
      fsGroup: 1000
      runAsGroup: 1000
      runAsNonRoot: true
      runAsUser: 1000
      seccompProfile:
        type: RuntimeDefault

  test:
    enabled: false

  traces:
    jaeger:
      grpc:
        # -- Enable Tempo to ingest Jaeger GRPC traces
        enabled: false
        # -- Jaeger GRPC receiver config
      thriftBinary:
        # -- Enable Tempo to ingest Jaeger Thrift Binary traces
        enabled: false
        # -- Jaeger Thrift Binary receiver config
      receiverConfig: {}
      thriftCompact:
        # -- Enable Tempo to ingest Jaeger Thrift Compact traces
        enabled: false
        # -- Jaeger Thrift Compact receiver config
      thriftHttp:
        # -- Enable Tempo to ingest Jaeger Thrift HTTP traces
        enabled: false
        # -- Jaeger Thrift HTTP receiver config
    otlp:
      http:
        # -- Enable Tempo to ingest Open Telemetry HTTP traces
        enabled: true
        # -- HTTP receiver advanced config
      grpc:
        # -- Enable Tempo to ingest Open Telemetry GRPC traces
        enabled: true
        # -- GRPC receiver advanced config
      receiverConfig:
        max_recv_msg_size_mib: 1000000000

# Ingress resources to send traces to Tempo over HTTP and gRPC
ingress:
  enabled: false
  ingressClassName: nginx
  host: ""
  # HTTP supports sending traces over OpenTelemetry API on /tempo/v1/traces
  # see https://opentelemetry.io/docs/specs/otlp/#otlphttp-request
  http:
    annotations:
      nginx.ingress.kubernetes.io/rewrite-target: /$1
    backends:
    - serviceName: tempo-distributor
      servicePort: 4318
      path: /tempo/(.*)
      pathType: ImplementationSpecific
  # gRPC supports sending traces over OpenTelemetry and Tempo methods
  # respectively opentelemetry.* and tempopb.*
  # Opentelemetry gRPC protocol: https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/trace/v1/trace.proto
  # Tempo gRPC protocol: https://github.com/grafana/tempo/blob/main/pkg/tempopb/tempo.proto
  grpc:
    annotations:
      nginx.ingress.kubernetes.io/backend-protocol: "GRPC"
      nginx.ingress.kubernetes.io/use-regex: "true"
    backends:
    - serviceName: tempo-distributor
      servicePort: 4317
      path: /opentelemetry
      pathType: ImplementationSpecific
    - serviceName: tempo-ingester
      servicePort: 3200
      path: /tempopb
      pathType: ImplementationSpecific

vulture:
  # You can make tempo-vulture ineffective by setting this one to "false"
  enabled: true

  extraArgs:
  - -tempo-org-id=giantswarm

  image:
    # -- Docker image repository
    repository: gsoci.azurecr.io/giantswarm/tempo-vulture

  # -- SecurityContext holds container-level security attributes and common container settings
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    seccompProfile:
      type: RuntimeDefault

  # -- podSecurityContext holds pod-level security attributes and common container settings
  podSecurityContext:
    fsGroup: 1000
    runAsGroup: 1000
    runAsNonRoot: true
    runAsUser: 1000
    seccompProfile:
      type: RuntimeDefault

  # PodMonitor configuration
  podMonitor:
    # -- If enabled, PodMonitor resources for Prometheus Operator are created
    enabled: true

  tempoAddress:
    # -- the url towards your Tempo distributor
    push: "http://tempo-distributor:4317"
    # -- the url towards your Tempo query-frontend
    query: "http://tempo-query-frontend"

  # -- Node affinity configuration to avoid control plane nodes
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: node-role.kubernetes.io/control-plane
            operator: DoesNotExist
